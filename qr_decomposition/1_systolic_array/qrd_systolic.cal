namespace qrd:
    // NOTE: joiner is a bit over the top
    // NOTE: SQRT does not work very well on hardware
    // NOTE: Remember to pull system stuff sqrt for example
    // Based on: https://doi.org/10.1117/12.932507 with extensions to allow Q matrix to be produced
    // @author Gareth Callanan

    import System.math.sqrt;

    // The size of the input square matrix
    uint K = 4;

    // The maximum number of tokens that can be stored in the FIFOS between actors.
    uint buffer_size= 3;

    // The Source actor needs to feed actors in an entire row from left to right. It takes 
    // K firings from the first firing on the left before the last actor on the right fires.
    // So to prevent the Source actor stalling while this value propogates, we set the 
    // buffers from the source actor to be > K (number of actor in the row). 
    uint source_buffer_size = buffer_size + K;

    // The buffer size of the filters needs to be >K as the filter requires K tokens to be
    // present in order to fire.
    uint filter_buffer_size = buffer_size + K;

    // The number of matrices that the SourceA and SourceB actors will generate.
    uint num_matrices=3;


    actor InnerCell(uint K) float x_in, float c_in, float s_in ==> float x_out, float c_out, float s_out, float r_out:
        float r := 0;
        uint count := 0;
        
        // NOTE: Mention on how r_out is not the best way always
        action x_in:[x_in], c_in:[c], s_in:[s]  ==> x_out:[x_out], c_out:[c], s_out:[s], r_out:[r]
        var 
            float x_out
        do
            if count = 0 then
                r := 0;
            end

            //println("Inner Cell Fired");
            x_out := -s*r + c*x_in;
            r := c*r+s*x_in;

            count := count + 1;
            if count = K then
                count := 0;
            end
        end
    end

    actor BoundaryCell(uint K) float x_in ==> float c_out, float s_out, float r_out:
        float r := 0;
        uint count := 0;
        
        action x_in:[x_in]  ==> c_out:[c], s_out:[s], r_out:[r]
        var
            float c,
            float s,
            float sqrt_result
        do
            //println("Boundary Cell Fired");
            if count = 0 then
                r := 0;
            end
            
            // Its better to treat very small values as zero.
            if x_in < 0.00001 and x_in > -0.00001 then
                c := 1;
                s := 0;
            else
                sqrt_result := sqrt(r*r+x_in*x_in);
                c := r/sqrt_result;
                s := x_in/sqrt_result;
                r := sqrt_result;
            end

            count := count + 1;
            if count = K then
                count := 0;
            end
        end
    end

    /**
     * Actor that generates sample source matrix B of size K*K. 
     *
     * The values in the array are the natural numbers starting from zero
     * incrementing by one first along a row and then along the column. Each 
     * *column* is output on a differet port. For example in a 2x3 array:
     *
     * Generated B:
     *        0 1 2      
     *        2 3 5
     *          
     * Port output:
     *     Out[0]: 0 2
     *     Out[1]: 1 3
     *     Out[2]: 2 5
     *
     * This matrix is produced "num_matrices" times
     *
     * @parameter  R - the number of rows in the matrix
     * @paramter   C - the number of columns in the matrix.
     * @outputport Out[C] - An array of ports that matrix B is output on.
     *                       Each column of the matrix is output on a different
     *                       port in the port array.
     */
    actor Source(uint K) ==> float Out[K]:
        int rowsOut := 0;
        int sentMatrices := 0;
        float next := 0.11;

        transmit: action ==> Out[0..K-1]:[output]
        guard sentMatrices < num_matrices
        var 
            List(type:float, size = K) output
        do
            foreach uint index in 0..K-1 do
                //print("" + (rowsOut * C + index) + " ");
                output[index] := next;
                next := next + 0.11;

                if (next >= 1) then
                    next := next - 1;
                end
            end
            //println("");
            rowsOut := rowsOut + 1;
            
            if(rowsOut = K) then
                rowsOut := 0;
                next := 0.11;
                sentMatrices := sentMatrices + 1;
            end
        end
    end

    actor IGenerator(uint col_index, uint K) ==> float Out:
        uint row_index := 0;
        uint total_rows := 0;

        action ==> Out:[outVal]
        guard
            total_rows < K*num_matrices
        var
            float outVal := 0
        do
            if(row_index = col_index) then
                outVal := 1;
            end
            
            row_index := (row_index + 1) mod K;
            total_rows := total_rows + 1;
        end

    end

    actor JoinerRowR(uint K, uint row_index, uint ports_in_row) float r_in[ports_in_row] ==>:
        uint matrix_number := 0;

        action r_in[0..ports_in_row-1]:[input] ==>
        do
            print("R"+matrix_number+": row " + row_index + ": ");
            if(row_index != 0) then
                foreach uint index in 0..(K-ports_in_row)-1 do
                    print("0 ");
                end
            end
            foreach uint index in 0..ports_in_row-1 do
                print("" + input[index] + " ");
            end
            println("");
            matrix_number := matrix_number + 1;
        end
    end

    actor JoinerRowQ(uint K, uint row_index) float r_in[K] ==>:
        uint matrix_number := 0;

        action r_in[0..K-1]:[input] ==>
        do
            print("Q"+matrix_number+": row " + row_index + ": ");
            foreach uint index in 0..K-1 do
                print("" + input[index] + " ");
            end
            println("");
            matrix_number := matrix_number + 1;
        end
    end

    /**
     * A fi
     *
     * @parameter  R - the number of rows in the matrix
     * @paramter   C - the number of columns in the matrix.
     * @outputport Out[R*C] - An array of ports that matrix C is received from.
     *                        Each processing element calculates a different
     *                        element in C and sends it to the collector on a 
     *                        different port.
     */
    actor Filter(uint num_tokens_to_filter) float In ==> float Out:
        action In:[in_tokens] repeat num_tokens_to_filter ==> Out:[in_tokens[num_tokens_to_filter-1]] end
    end

    /**
     * This actor is mean to be attached to unused output ports, consuming tokens from the FIFO
     * to prevent the buffers filling up and the pipelining stalling. I do not know if these are 
     * actually necessary in all cases but some CAL backends we test with are not so mature
     * so maybe its best to have them here just in case.
     */ 
    actor Cap(uint index) int In ==>:
        receive: action In:[t] ==> end
    end



    /*network Top() ==>:
    entities
        source = Source(K=K);
        sourcePrinter = SourcePrinter(K=K);
    structure
        foreach uint i in 0..K-1 do
            source.Out[i] --> sourcePrinter.In[i];
        end
    end*/

    /**      0 1 2 3
     *    0  B I I I I I I I
     *    1    B I I I I I I
     *    2      B I I I I I
     *    3        B I I I I
     */
    network Top() ==>:
    var 
        function getInnerCellIndex(int row_index, int col_index) --> int : 
            (K*(K-1)/2) - (K-row_index)*((K-row_index)-1)/2 + col_index - row_index - 1 end
    entities
        // Actors that generate input data
        source = Source(K=K);
        iGenerator=[IGenerator(col_index=index, K=K): for index in 0..K-1];
        
        // Actors that perform the actual QR decomposition
        boundaryCells=[BoundaryCell(K=K): for index in 0..K-1];
        innerCells_r=[InnerCell(K=K): for index in 0..(K-1)*(K)/2-1];
        innerCells_q=[InnerCell(K=K): for index in 0..(K)*(K)-1];
        
        // Actor that assemble the Q and R matrices produced from the boundary and inner cells
        filters_r_boundary = [Filter(num_tokens_to_filter=K): for index in 0..K-1];
        filters_r_inner = [Filter(num_tokens_to_filter=K): for index in 0..(K-1)*(K)/2-1];
        filters_q = [Filter(num_tokens_to_filter=K): for index in 0..(K)*(K)-1 ];
        joinersPerRow_r=[JoinerRowR(K=K, row_index=index, ports_in_row=(K-index)): for index in 0..K-1];
        joinersPerRow_q=[JoinerRowQ(K=K, row_index=index): for index in 0..K-1];

        // Caps for unused ports 
        caps_s=[Cap(index=0): for index in 0..K-1];
        caps_c=[Cap(index=0): for index in 0..K-1];
        caps_x=[Cap(index=0): for index in 0..K-1];    
    structure
        // 1. Connect the triangular part of the array
        foreach uint r in 0..K-1 do // Iterate along rows in triangle
            foreach uint c in r..K-1 do // Iterate along columns in the triangle

                if r=0 && c=0 then
                    source.Out[0] --> boundaryCells[0].x_in {bufferSize = source_buffer_size;};
                end

                if r=0 && c!=0 then
                    source.Out[c] --> innerCells_r[c-1].x_in {bufferSize = source_buffer_size;};
                end

                // Connect c_in,s_in to c_out,s_out along each innerCell
                if c > r then
                    if c = K-1 then
                        innerCells_r[getInnerCellIndex(r,c)].c_out --> innerCells_q[r*K].c_in {bufferSize = buffer_size;};
                        innerCells_r[getInnerCellIndex(r,c)].s_out --> innerCells_q[r*K].s_in {bufferSize = buffer_size;};
                    else
                        innerCells_r[getInnerCellIndex(r,c)].c_out --> innerCells_r[getInnerCellIndex(r,c+1)].c_in {bufferSize = buffer_size;};
                        innerCells_r[getInnerCellIndex(r,c)].s_out --> innerCells_r[getInnerCellIndex(r,c+1)].s_in {bufferSize = buffer_size;};
                    end

                    if c = r+1 then
                        innerCells_r[getInnerCellIndex(r,c)].x_out --> boundaryCells[r+1].x_in {bufferSize = buffer_size;};
                    else
                        innerCells_r[getInnerCellIndex(r,c)].x_out --> innerCells_r[getInnerCellIndex(r+1,c)].x_in {bufferSize = buffer_size;};
                    end

                    innerCells_r[getInnerCellIndex(r,c)].r_out --> filters_r_inner[getInnerCellIndex(r,c)].In {bufferSize = filter_buffer_size;};
                    filters_r_inner[getInnerCellIndex(r,c)].Out --> joinersPerRow_r[r].r_in[c-r] {bufferSize = buffer_size;};
                end

                // Connect boundry cells c_out and s_out
                if r = c then
                    if(r = K - 1) then // The last boundary in the chain
                        boundaryCells[r].c_out --> innerCells_q[r*K].c_in {bufferSize = buffer_size;};
                        boundaryCells[r].s_out --> innerCells_q[r*K].s_in {bufferSize = buffer_size;};
                    else
                        boundaryCells[r].c_out --> innerCells_r[getInnerCellIndex(r,c+1)].c_in {bufferSize = buffer_size;};
                        boundaryCells[r].s_out --> innerCells_r[getInnerCellIndex(r,c+1)].s_in {bufferSize = buffer_size;};
                    end

                    boundaryCells[r].r_out --> filters_r_boundary[r].In {bufferSize = filter_buffer_size;};
                    filters_r_boundary[r].Out --> joinersPerRow_r[r].r_in[0] {bufferSize = buffer_size;};
                end

            end
        end

        // 2. Connect the square part of the array
        foreach uint r in 0..K-1 do // Iterate along rows in the square
            foreach uint c in 0..K-1 do // Iterate along columns in the square
                // 2.1  Connect iGenerator to the array
                if r = 0 then
                    iGenerator[c].Out --> innerCells_q[r*K + c].x_in {bufferSize = buffer_size;};
                end
                
                // 2.2 Connect the actors in a column together
                if r = K-1 then
                    innerCells_q[r*K + c].x_out --> caps_x[c].In {bufferSize = buffer_size;};
                else
                    innerCells_q[r*K + c].x_out --> innerCells_q[(r+1)*K + c].x_in {bufferSize = buffer_size;};
                end
 
                // 2.3 Connect all actors in a row together
                if(c = K-1) then
                    innerCells_q[r*K + c].c_out --> caps_c[r].In {bufferSize = buffer_size;};
                    innerCells_q[r*K + c].s_out --> caps_s[r].In {bufferSize = buffer_size;};
                else
                    innerCells_q[r*K + c].c_out --> innerCells_q[r*K + c + 1].c_in {bufferSize = buffer_size;};
                    innerCells_q[r*K + c].s_out --> innerCells_q[r*K + c + 1].s_in {bufferSize = buffer_size;};
                end

                // 2.4 Connect the generated Q matrix values to the joiner. The generated matrix is
                // Q^T, so we connect each column to each joiner row to transpose backward
                
                innerCells_q[r*K + c].r_out --> filters_q[r*K + c].In {bufferSize = filter_buffer_size;}; 
                filters_q[r*K + c].Out --> joinersPerRow_q[c].r_in[r] {bufferSize = buffer_size;};
            end
        end
    end
end