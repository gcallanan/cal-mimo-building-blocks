namespace qrd:
    // NOTE: joiner is a bit over the top
    // NOTE: SQRT does not work very well on hardware
    // NOTE: Remember to pull system stuff sqrt for example
    // Based on: https://doi.org/10.1117/12.932507

    import System.math.sqrt;

    // The size of the input square matrix
    uint K = 3;

    // The maximum number of tokens that can be stored in the FIFOS between actors.
    uint buffer_size=3;

    // The size of the joiner buffers. They need to be large enough to store K values in the worst
    // case to prevent stalling. This is because each joiner requires data from all elements in
    // the row. There are K elements in the row and it takes K firings after the leftmost element
    // has fired before the element on the right side of the row fires for the corresponding input.
    // We still want the left most elements to keep firing, and as such we add this buffer
    uint joiner_buffer_size = K+buffer_size;

    // The number of matrices that the SourceA and SourceB actors will generate.
    uint num_matrices=3;

    /**
     * Actor that generates sample source matrix B of size K*K. 
     *
     * The values in the array are the natural numbers starting from zero
     * incrementing by one first along a row and then along the column. Each 
     * *column* is output on a differet port. For example in a 2x3 array:
     *
     * Generated B:
     *        0 1 2      
     *        2 3 5
     *          
     * Port output:
     *     Out[0]: 0 2
     *     Out[1]: 1 3
     *     Out[2]: 2 5
     *
     * This matrix is produced "num_matrices" times
     *
     * @parameter  R - the number of rows in the matrix
     * @paramter   C - the number of columns in the matrix.
     * @outputport Out[C] - An array of ports that matrix B is output on.
     *                       Each column of the matrix is output on a different
     *                       port in the port array.
     */
    actor Source(uint K) ==> float Out[K]:
        int rowsOut := 0;
        int sentMatrices := 0;
        float next := 0.11;

        transmit: action ==> Out[0..K-1]:[output]
        guard sentMatrices < num_matrices
        var 
            List(type:float, size = K) output
        do
            foreach uint index in 0..K-1 do
                //print("" + (rowsOut * C + index) + " ");
                output[index] := next;
                next := next + 0.11;

                if (next >= 1) then
                    next := next - 1;
                end
            end
            //println("");
            rowsOut := rowsOut + 1;
            
            if(rowsOut = K) then
                rowsOut := 0;
                next := 0.11;
                sentMatrices := sentMatrices + 1;
            end
        end
    end

    actor InnerCell(uint K, uint toPrint) float x_in, float c_in, float s_in ==> float x_out, float c_out, float s_out, float r_out:
        float r := 0;
        uint count := 0;
        
        // NOTE: Mention on how r_out is not the best way always
        action x_in:[x_in], c_in:[c], s_in:[s]  ==> x_out:[x_out], c_out:[c], s_out:[s], r_out:[r]
        var 
            float x_out
        do
            if count = 0 then
                r := 0;
            end

            //println("Inner Cell Fired");
            x_out := -s*r + c*x_in;
            r := c*r+s*x_in;

            count := count + 1;
            if count = K then
                count := 0;
                if toPrint = 1 then
                    println("" + r);
                end
            end
        end
    end

    actor BoundaryCell(uint K) float x_in ==> float c_out, float s_out, float r_out:
        float r := 0;
        uint count := 0;
        
        action x_in:[x_in]  ==> c_out:[c], s_out:[s], r_out:[r]
        var
            float c,
            float s,
            float sqrt_result
        do
            //println("Boundary Cell Fired");
            if count = 0 then
                r := 0;
            end
            
            if x_in = 0 then
                c := 1;
                s := 0;
            else
                sqrt_result := sqrt(r*r+x_in*x_in);
                c := r/sqrt_result;
                s := x_in/sqrt_result;
                r := sqrt_result;
            end

            count := count + 1;
            if count = K then
                count := 0;
            end
        end
    end

    actor IGenerator(uint col_index, uint K) ==> float Out:
        uint row_index := 0;
        uint total_rows := 0;

        action ==> Out:[outVal]
        guard
            total_rows < K*num_matrices
        var
            float outVal := 0
        do
            if(row_index = col_index) then
                outVal := 1;
            end
            
            //println("" + row_index + "," + col_index + ":" + outVal);

            row_index := (row_index + 1) mod K;
            total_rows := total_rows + 1;
        end

    end

    actor JoinerRowR(uint K, uint row_index, uint ports_in_row) float r_in[K] ==>:
        uint count := 0;

        action r_in[0..ports_in_row-1]:[input] ==>
        do
            count := count + 1;
            
            if count = K then
                print("R: row " + row_index + ": ");
                if(row_index != 0) then
                    foreach uint index in 0..(K-ports_in_row)-1 do
                        print("0 ");
                    end
                end
                foreach uint index in 0..ports_in_row-1 do
                    print("" + input[index] + " ");
                end
                println("");
                count := 0;
            end
        end
    end

    actor JoinerRowQ(uint K, uint row_index) float r_in[K] ==>:
        uint count := 0;

        action r_in[0..K-1]:[input] ==>
        do
            count := count + 1;
            
            if count = K then
                print("Q: row " + row_index + ": ");
                foreach uint index in 0..K-1 do
                    print("" + input[index] + " ");
                end
                println("");
                count := 0;
            end
        end
    end

    actor SourcePrinter(uint K, int toPrint) float In[K] ==> :
        action In[0..K-1]:[input] ==>
        do
            if toPrint != 0 then
                print("" + toPrint + ": ");
                foreach uint index in 0..K-1 do
                    print("" + input[index] + " ");
                end 
                println("");
            end
        end
    end

    actor Cap(uint index) int In ==>:
        receive: action In:[t] ==> 
        do
            //println("" + index + ":" + t);
        end
    end


    /*network Top() ==>:
    entities
        source = Source(K=K);
        sourcePrinter = SourcePrinter(K=K);
    structure
        foreach uint i in 0..K-1 do
            source.Out[i] --> sourcePrinter.In[i];
        end
    end*/

    /**      0 1 2 3
     *    0  B I I I I I I I
     *    1    B I I I I I I
     *    2      B I I I I I
     *    3        B I I I I
     */
    network Top() ==>:
    var 
        function getInnerCellIndex(int row_index, int col_index) --> int : 
            (K*(K-1)/2) - (K-row_index)*((K-row_index)-1)/2 + col_index - row_index - 1 end
    entities
        source = Source(K=K);
        iGenerator=[IGenerator(col_index=index, K=K): for index in 0..K-1];
        caps_s=[Cap(index=0): for index in 0..K-1];
        caps_c=[Cap(index=0): for index in 0..K-1];
        caps_x=[Cap(index=0): for index in 0..K-1];
        boundaryCells=[BoundaryCell(K=K): for index in 0..K-1];
        joinersPerRow_r=[JoinerRowR(K=K, row_index=index, ports_in_row=(K-index)): for index in 0..K-1];
        joinersPerRow_q=[JoinerRowQ(K=K, row_index=index): for index in 0..K-1];
        innerCells_r=[InnerCell(K=K, toPrint=0): for index in 0..(K-1)*(K)/2-1];
        innerCells_q=[InnerCell(K=K, toPrint=0): for index in 0..(K)*(K)-1];
    structure
        
        // 1. Connect the triangular part of the array
        foreach uint r in 0..K-1 do // Iterate along rows in triangle
            foreach uint c in r..K-1 do // Iterate along columns in the triangle

                if r=0 && c=0 then
                    source.Out[0] --> boundaryCells[0].x_in {bufferSize = buffer_size;};
                end

                if r=0 && c!=0 then
                    source.Out[c] --> innerCells_r[c-1].x_in {bufferSize = buffer_size;};
                end

                // Connect c_in,s_in to c_out,s_out along each innerCell
                if c > r then
                    if c = K-1 then
                        innerCells_r[getInnerCellIndex(r,c)].c_out --> innerCells_q[r*K].c_in {bufferSize = buffer_size;};
                        innerCells_r[getInnerCellIndex(r,c)].s_out --> innerCells_q[r*K].s_in {bufferSize = buffer_size;};
                    else
                        innerCells_r[getInnerCellIndex(r,c)].c_out --> innerCells_r[getInnerCellIndex(r,c+1)].c_in {bufferSize = buffer_size;};
                        innerCells_r[getInnerCellIndex(r,c)].s_out --> innerCells_r[getInnerCellIndex(r,c+1)].s_in {bufferSize = buffer_size;};
                    end

                    if c = r+1 then
                        innerCells_r[getInnerCellIndex(r,c)].x_out --> boundaryCells[r+1].x_in {bufferSize = buffer_size;};
                    else
                        innerCells_r[getInnerCellIndex(r,c)].x_out --> innerCells_r[getInnerCellIndex(r+1,c)].x_in {bufferSize = buffer_size;};
                    end

                    innerCells_r[getInnerCellIndex(r,c)].r_out --> joinersPerRow_r[r].r_in[c-r] {bufferSize = joiner_buffer_size;};
                end

                // Connect boundry cells c_out and s_out
                if r = c then
                    if(r = K - 1) then // The last boundary in the chain
                        boundaryCells[r].c_out --> innerCells_q[r*K].c_in {bufferSize = buffer_size;};
                        boundaryCells[r].s_out --> innerCells_q[r*K].s_in {bufferSize = buffer_size;};
                    else
                        boundaryCells[r].c_out --> innerCells_r[getInnerCellIndex(r,c+1)].c_in {bufferSize = buffer_size;};
                        boundaryCells[r].s_out --> innerCells_r[getInnerCellIndex(r,c+1)].s_in {bufferSize = buffer_size;};
                    end

                    boundaryCells[r].r_out --> joinersPerRow_r[r].r_in[0] {bufferSize = joiner_buffer_size;};
                end

            end
        end

        // 2. Connect the square part of the array
        foreach uint r in 0..K-1 do // Iterate along rows in the square
            foreach uint c in 0..K-1 do // Iterate along columns in the square
                // 2.1  Connect iGenerator to the array
                if r = 0 then
                    iGenerator[c].Out --> innerCells_q[r*K + c].x_in {bufferSize = buffer_size;};
                end
                
                // 2.2 Connect the actors in a column together
                if r = K-1 then
                    innerCells_q[r*K + c].x_out --> caps_x[c].In {bufferSize = buffer_size;};
                else
                    innerCells_q[r*K + c].x_out --> innerCells_q[(r+1)*K + c].x_in {bufferSize = buffer_size;};
                end
 
                // 2.3 Connect all actors in a row together
                if(c = K-1) then
                    innerCells_q[r*K + c].c_out --> caps_c[r].In {bufferSize = buffer_size;};
                    innerCells_q[r*K + c].s_out --> caps_s[r].In {bufferSize = buffer_size;};
                else
                    innerCells_q[r*K + c].c_out --> innerCells_q[r*K + c + 1].c_in {bufferSize = buffer_size;};
                    innerCells_q[r*K + c].s_out --> innerCells_q[r*K + c + 1].s_in {bufferSize = buffer_size;};
                end

                // 2.4 Connect the generated Q matrix values to the joiner. The generated matrix is
                // Q^T, so we connect each column to each joiner row to transpose backward
                innerCells_q[r*K + c].r_out --> joinersPerRow_q[c].r_in[r];
            end
        end
    end
end