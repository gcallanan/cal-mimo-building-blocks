namespace mat_mul:
    uint A_ROWS = 4;
    uint A_COLS_B_ROWS = 5;
    uint B_COLS = 6;
    uint buffer_size=10;

    actor SourceA(uint R, uint C) ==> int Out[R]:
        int colsOut := 0;
        transmit: action ==> Out[0..R-1]:[output]
        guard colsOut < C
        var 
            List(type:int, size = R) output
        do
            foreach uint index in 0..R-1 do
                output[index] := index * C + colsOut;
            end
            colsOut := colsOut + 1;
        end
    end

    actor SourceB(uint R, uint C) ==> int Out[C]:
        int rowsOut := 0;
        transmit: action ==> Out[0..C-1]:[output]
        guard rowsOut < R
        var 
            List(type:int, size = C) output
        do
            foreach uint index in 0..C-1 do
                //print("" + (rowsOut * C + index) + " ");
                output[index] := rowsOut * C + index;
            end
            //println("");
            rowsOut := rowsOut + 1;
        end
    end

    actor PE(uint common_dimension, uint R_index, uint C_index) int In_top, int In_left ==> int Out_bot, int Out_right, int C_element:
        int product;
        int num_calculations;
        
        normal: action In_left:[a], In_top:[b] ==> Out_right:[a], Out_bot:[b]
        do
            product := product + a*b;
            num_calculations := num_calculations + 1;
        end

        done: action ==> C_element:[outputProduct]
        guard
            num_calculations = common_dimension
        var
            int outputProduct = product
        do 
            //println("PE " + R_index + "," + C_index + ": " + product);
            product := 0;
            num_calculations := 0;
        end

        priority 
            done > normal;
        end
    end

    actor PERight(uint common_dimension, uint R_index, uint C_index) int In_top, int In_left ==> int Out_bot, int C_element:
        int product;
        int num_calculations;
        
        normal: action In_left:[a], In_top:[b] ==> Out_bot:[b]
        do
            product := product + a*b;
            num_calculations := num_calculations + 1;
        end

        done: action ==> C_element:[outputProduct]
        guard
            num_calculations = common_dimension
        var
            int outputProduct = product
        do 
            //println("PE_R " + R_index + "," + C_index + ": " + product);
            product := 0;
            num_calculations := 0;
        end

        priority 
            done > normal;
        end
    end

    actor PEBottom(uint common_dimension, uint R_index, uint C_index) int In_top, int In_left ==> int Out_right, int C_element:
        int product;
        int num_calculations;
        
        normal: action In_left:[a], In_top:[b] ==> Out_right:[a]
        do
            product := product + a*b;
            num_calculations := num_calculations + 1;
        end

        done: action ==> C_element:[outputProduct]
        guard
            num_calculations = common_dimension
        var
            int outputProduct = product
        do 
            //println("PE_B " + R_index + "," + C_index + ": " + product);
            product := 0;
            num_calculations := 0;
        end

        priority 
            done > normal;
        end
    end

    actor PEBottomRight(uint common_dimension, uint R_index, uint C_index) int In_top, int In_left ==> int C_element:
        int product;
        int num_calculations;
        
        normal: action In_left:[a], In_top:[b] ==>
        do
            product := product + a*b;
            num_calculations := num_calculations + 1;
        end

        done: action ==> C_element:[outputProduct]
        guard
            num_calculations = common_dimension
        var
            int outputProduct = product
        do  
            //println("PE_BR " + R_index + "," + C_index + ": " + product);
            product := 0;
            num_calculations := 0;
        end

        priority 
            done > normal;
        end
    end

    actor Collector(uint R, uint C) int In[R*C] ==>:
        action In[0..((R*C)-1)]:[matrix] ==>
        do
            foreach uint r in 0..R-1 do
                foreach uint c in 0..C-1 do
                    print("" + matrix[r * C + c] + " ");
                end
                println("");
            end
        end
    end

    network Top() ==>:
    entities
        sourceA = SourceA(R=A_ROWS,C=A_COLS_B_ROWS);
        sourceB = SourceB(R=A_COLS_B_ROWS,C=B_COLS);
        pes=[PE(common_dimension=A_COLS_B_ROWS, R_index= index / (B_COLS-1), C_index=(index mod (B_COLS-1))): for index in 0..(A_ROWS-1)*(B_COLS-1)-1];
        pes_right = [PERight(common_dimension=A_COLS_B_ROWS, R_index=r, C_index=B_COLS-1): for r in 0..A_ROWS-2];
        pes_bottom = [PEBottom(common_dimension=A_COLS_B_ROWS, R_index=A_ROWS-1, C_index=c): for c in 0..B_COLS-2];
        pe_bottom_right = PEBottomRight(common_dimension=A_COLS_B_ROWS, R_index=A_ROWS-1, C_index=B_COLS-1);
        collector = Collector(R=A_ROWS,C=B_COLS);
    structure
        // Connect matrix A source to grid
        foreach uint i in 0..A_ROWS-2 do
            sourceA.Out[i] --> pes[i*(B_COLS-1)].In_left {bufferSize = buffer_size;};
        end
        sourceA.Out[A_ROWS-1] --> pes_bottom[0].In_left {bufferSize = buffer_size;};

        // Connect matrix B source to grid
        foreach uint i in 0..B_COLS-2 do
            sourceB.Out[i] --> pes[i].In_top {bufferSize = buffer_size;};
        end
        sourceB.Out[B_COLS-1] --> pes_right[0].In_top {bufferSize = buffer_size;};

        // Connect all grid elements to each other
        foreach uint row_index in 0..A_ROWS-1 do
            foreach uint col_index in 0..B_COLS-1 do
                if row_index < A_ROWS-2 && col_index < B_COLS-2 then
                    pes[row_index*(B_COLS-1) + col_index].Out_right --> pes[row_index*(B_COLS-1) + col_index + 1].In_left {bufferSize = buffer_size;};
                    pes[row_index*(B_COLS-1) + col_index].Out_bot --> pes[(row_index+1)*(B_COLS-1) + col_index].In_top {bufferSize = buffer_size;};
                    pes[row_index*(B_COLS-1) + col_index].C_element --> collector.In[row_index*(B_COLS) + col_index] {bufferSize = buffer_size;};
                end

                if (row_index = A_ROWS-2 && col_index = B_COLS-2) then
                    pes[row_index*(B_COLS-1) + col_index].Out_bot --> pes_bottom[col_index].In_top {bufferSize = buffer_size;};
                    pes[row_index*(B_COLS-1) + col_index].Out_right --> pes_right[row_index].In_left {bufferSize = buffer_size;};
                    pes[row_index*(B_COLS-1) + col_index].C_element --> collector.In[row_index*(B_COLS) + col_index] {bufferSize = buffer_size;};
                end

                if row_index = A_ROWS-2 && col_index < B_COLS-2 then
                    pes[row_index*(B_COLS-1) + col_index].Out_right --> pes[row_index*(B_COLS-1) + col_index + 1].In_left {bufferSize = buffer_size;};
                    pes[row_index*(B_COLS-1) + col_index].Out_bot --> pes_bottom[col_index].In_top {bufferSize = buffer_size;};
                    pes[row_index*(B_COLS-1) + col_index].C_element --> collector.In[row_index*(B_COLS) + col_index] {bufferSize = buffer_size;};
                end

                if row_index = A_ROWS-1 && col_index < B_COLS-2 then
                    pes_bottom[col_index].Out_right --> pes_bottom[col_index+1].In_left {bufferSize = buffer_size;};
                    pes_bottom[col_index].C_element --> collector.In[row_index*(B_COLS) + col_index] {bufferSize = buffer_size;};
                end

                if row_index = A_ROWS-1 && col_index = B_COLS-2 then
                    pes_bottom[col_index].Out_right --> pe_bottom_right.In_left {bufferSize = buffer_size;};
                    pes_bottom[col_index].C_element --> collector.In[row_index*(B_COLS) + col_index] {bufferSize = buffer_size;};
                end

                if row_index < A_ROWS-2 && col_index = B_COLS-2 then
                    pes[row_index*(B_COLS-1) + col_index].Out_bot --> pes[(row_index+1)*(B_COLS-1) + col_index].In_top {bufferSize = buffer_size;};
                    pes[row_index*(B_COLS-1) + col_index].Out_right --> pes_right[row_index].In_left {bufferSize = buffer_size;};
                    pes[row_index*(B_COLS-1) + col_index].C_element --> collector.In[row_index*(B_COLS) + col_index] {bufferSize = buffer_size;};
                end

                if row_index < A_ROWS-2 && col_index = B_COLS-1 then
                     pes_right[row_index].Out_bot --> pes_right[row_index+1].In_top {bufferSize = buffer_size;};
                     pes_right[row_index].C_element --> collector.In[row_index*(B_COLS) + col_index] {bufferSize = buffer_size;};
                end

                if row_index = A_ROWS-2 && col_index = B_COLS-1 then
                     pes_right[row_index].Out_bot --> pe_bottom_right.In_top {bufferSize = buffer_size;};
                     pes_right[row_index].C_element --> collector.In[row_index*(B_COLS) + col_index] {bufferSize = buffer_size;};
                end

                if row_index = A_ROWS-1 && col_index = B_COLS-1 then
                    pe_bottom_right.C_element --> collector.In[row_index*(B_COLS) + col_index] {bufferSize = buffer_size;};
                end
            end
        end
    end

    actor SinkA(uint R, uint C) int In[R] ==> :
        List(type:int, size=R*C) matrix;
        uint receivedCols := 0;

        receive: action In[0..R-1]:[t] ==> 
        do
            foreach uint index in 0..R-1 do
                matrix[index * C + receivedCols] := t[index];
            end
            receivedCols := receivedCols + 1;
        end

        print: action ==>
        guard 
            receivedCols = C
        do
            receivedCols := 0;
            foreach uint row_index in 0..R-1 do
                foreach uint col_index in 0..C-1 do
                    print("" + matrix[row_index*C + col_index] + " ");
                end
                println("");
            end
        end
    end

    actor SinkB(uint R, uint C) int In[C] ==> :
        List(type:int, size=R*C) matrix;
        uint receivedRows := 0;

        receive: action In[0..C-1]:[t] ==> 
        do
            foreach uint index in 0..C-1 do
                print("" + t[index] + " ");
                matrix[receivedRows * C + index] := t[index];
            end
            println("");
            receivedRows := receivedRows + 1;
        end

        print: action ==>
        guard 
            receivedRows = R
        do
            println("Done!");
            receivedRows := 0;
        end
    end

end

